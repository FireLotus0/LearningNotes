###  设计模式中，接口用纯虚基类实现

### 禁止过度设计，遵守需求驱动，保持持续重构,但随时保持封装意识，抽象意识，扩展意识。常用来提高扩展性的方法有：多态，依赖注入，基于接口编程，以及大部分的设计模式(装饰，模版，策略，职责链，状态)

### 思考：
	- 如果A和B不具有父子关系，也不具有兄弟关系，但是他们都需要实现某个功能的一段代码，按照面向对象思想，继承可以实现代码复用，然而，问题是这两个类并无关系，为了实现复用硬生生创建出一个基类，导致代码可读性大大降低。
	- 实现一个只具有静态方法没有任何属性的类，是完全面向过程的编程方式。可以用，不能滥用。可以适当细化，例如将Utils分成？FileUntils，IOUntils,NetUntils...
	- 抽象类和接口的区别：抽象类可以定义属性，接口不行。抽象类更多的表示一种is-a关系，解决代码复用问题，接口更多的表示一种has-a关系，具有某种功能，接口也可以称作协议，将接口和实现分离，实现代码解耦，提高扩展性。
	- 基于接口编程而非实现。越顶层，越脱离具体的实现，越能应对需求的变化，提高灵活性，扩展性和可维护性。
	- 什么时候时候使用接口，什么时候直接使用实现类？回到设计原则的本质上来即可区分。
	- 理论上讲通过组合和接口可以替代继承：继承的三个作用：1.表达is-a的关系(通过组合和接口的has-a替代), 2.代码复用(通过组合和委托替代)， 3.实现多态(通过接口替代)
	- 如何选择组合，继承：扬长避短，如果类继承结构稳定，继承关系简单，则使用继承；反之，考虑组合
```CPP
class IoInterface{
public:
	virtual func_1() = 0;
	virtual func_2() = 0;
	virtual func_3() = 0;
	
	virtual ~IoInterface();
};

class IoAbstract{
public:
	virtual  func_1() = 0;
	virtual func_2() = 0;

	virtual ~IoAbstract();

private:
	int fd = 0;
};

```

#### 判断是否满足单一职责原则：
	- 如果代码行数过多，接口过多，考虑对类进行拆分
	- 类依赖的其他类过多，不满足高内聚，低耦合的设计思想，考虑拆分
	- 私有方法过多，考虑拆分
	- 如果发现不好给一个类取名字，难以体现其业务功能，考虑拆分
	- 类中的大量方法针对某一个或几个属性，考虑拆分


#### 依赖反转原则：高层模块不应该依赖底层模块，抽象不应该依赖实现
	- 控制反转：控制指的是对程序执行流程的控制。IOC是一种设计思想，相对笼统，即设计一种代码骨架，使用框架前，程序执行流程由程序员自己控制，使用框架后执行流程交给框架控制，程序员只需要在预留的扩展点添加业务代码即可。
	- 依赖注入：将依赖的类传递进来使用，可以对其进行替换，提高灵活性，不在类中创建依赖对象，而是在外部创建好后，传递进来。
	- 依赖注入框架：通过框架预留的扩展点，简单的配置一下类以及类之间的关系，实现框架自动创建对象，管理对象生命周期
	- 依赖反转：高层模块不依赖底层模块，二者共同依赖一个抽象


#### 开闭原则：理性看待开闭原则，尽量让修改操作更集中，更上层，更少，尽量让代码逻辑复杂的部分满足开闭原则

#### 如何给代码解耦：
	- 封装和抽象
	- 引入中间层
	- 模块化

### 创建形模式 
#### 工厂模式：将对象的创建封装在一个工厂类中，不在客户端代码中直接实例化对象，提高扩展性和维护性。
- 分类：
	- 简单工厂模式：不是一个正式的设计模式，但是工厂模式的基础。使用一个单独的工厂类根据传入的参数创建不同的对象。
	- 工厂方法模式：在纯虚基类中提供创建对象的接口，在子类中实现具体对象的创建
	- 抽象工厂模式：提供创建创建一系列相关或互相依赖的对象的接口
- 使用场景：根据不同的条件创建不同的实例对象
	- 日志记录：日志记录可能记录到磁盘，系统事件，远程服务器；或者日志记录的内容可以根据配置变更，如：行号，时间，线程...
	- 数据库连接：数据库源可切换，用户并不知道实际使用哪一个
	- 连接服务器框架设计：数据库连接需要支持pop3,ssh,http等，可将这些协议作为一个产品类
-  注意事项：
	- 工厂模式适用于创建比较复杂的对象，对于简单对象直接通过new创建即可，使用工厂模式反而增加复杂性

#### 抽象工厂模式：抽象工厂是创建其他工厂的工厂，也叫超级工厂。通过使用抽象工厂，可以将客户端与具体产品的创建过程解耦，客户端可以通过工厂接口创建一族产品。
- 实现方式：提供一个创建一系列相关或相互依赖的接口，而不用指定他们的具体类，关键在一个工厂中提供多个同类产品的创建方法

- 使用场景：衣柜类(抽象工厂)，每个衣柜(具体工厂)，每个衣柜存放一类衣服(成套的一系列产品).
	- QQ换皮肤时，所有整套皮肤一起换
	- 创建跨平台应用时，同时生成其他操作系统的应用程序
- 注意事项：扩展产品族非常困难，需要修改抽象工厂和所有具体工厂的代码。


#### Builder模式：在软件系统中，某个对象的构造比较复杂，由各个子部分构成，但是随着需求的变化，子部分剧烈变化，但是将各个子部分组建起来的算法相对稳定，这就是构建者模式。目的在于实现将复杂对象的构建与其表示分离，使得相同的构建过程可以表达不同的变化。


#### 原型模式：
	- 优点：
		1. 性能优良：原型模式是内存二进制流的拷贝，当new的对象比较复杂的时候，尤其在一个循环体内产生，此时原型模式性能较好。
		2. 原型模式允许在运行期间，由客户自己注册满足原型模式接口的类型，接口没有变化，但实际上运行的已经是另一个类了
	- 缺点：
		1. 不通过构造函数
		2. 每个类需要提供一个clone的方法。
	- 适用场景：
		1. 需要创建的对象比较复杂，包括软硬件资源
		2. 当new一个对象需要复杂的属性或者权限时
		3. 当一个对象需要提供给其他人使用，并且其他人可能会修改对象属性，可以创建多个对象供其调用，也称为保护性拷贝。


